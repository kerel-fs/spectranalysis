/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/spectroplot/lib/fft_nayuki.js":
/*!****************************************************!*\
  !*** ./node_modules/spectroplot/lib/fft_nayuki.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * @file Free FFT and convolution (JavaScript)\n *\n * @copyright 2017 Project Nayuki. (MIT License)\n * @see https://www.nayuki.io/page/free-small-fft-in-multiple-languages\n * @author Wrapped as ES6 module by Christian W. Zuckschwerdt <zany@triq.net>\n * @license\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\n/*\n * Construct an object for calculating the discrete Fourier transform (DFT) of size n, where n is a power of 2.\n */\nclass FFTNayuki {\n    constructor(n) {\n        this.n = n;\n        this.levels = -1;\n\n        // Length variables\n        for (let i = 0; i < 32; i++) {\n            if (1 << i == n)\n                this.levels = i;  // Equal to log2(n)\n        }\n        if (this.levels == -1)\n            throw 'Length is not a power of 2';\n\n        // Trigonometric tables\n        this.cosTable = new Array(n / 2);\n        this.sinTable = new Array(n / 2);\n        for (let i = 0; i < n / 2; i++) {\n            this.cosTable[i] = Math.cos(2 * Math.PI * i / n);\n            this.sinTable[i] = Math.sin(2 * Math.PI * i / n);\n        }\n    }\n\n    /*\n     * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n     * The vector's length must be a power of 2. Uses the Cooley-Tukey decimation-in-time radix-2 algorithm.\n     */\n    transform(real, imag) {\n        const n = this.n;\n\n        // Bit-reversed addressing permutation\n        for (let i = 0; i < n; i++) {\n            const j = reverseBits(i, this.levels);\n            if (j > i) {\n                let temp = real[i];\n                real[i] = real[j];\n                real[j] = temp;\n                temp = imag[i];\n                imag[i] = imag[j];\n                imag[j] = temp;\n            }\n        }\n\n        // Cooley-Tukey decimation-in-time radix-2 FFT\n        for (let size = 2; size <= n; size *= 2) {\n            const halfsize = size / 2;\n            const tablestep = n / size;\n            for (let i = 0; i < n; i += size) {\n                for (let j = i, k = 0; j < i + halfsize; j++, k += tablestep) {\n                    const l = j + halfsize;\n                    const tpre =  real[l] * this.cosTable[k] + imag[l] * this.sinTable[k];\n                    const tpim = -real[l] * this.sinTable[k] + imag[l] * this.cosTable[k];\n                    real[l] = real[j] - tpre;\n                    imag[l] = imag[j] - tpim;\n                    real[j] += tpre;\n                    imag[j] += tpim;\n                }\n            }\n        }\n\n        // Returns the integer whose value is the reverse of the lowest 'bits' bits of the integer 'x'.\n        function reverseBits(x, bits) {\n            let y = 0;\n            for (let i = 0; i < bits; i++) {\n                y = (y << 1) | (x & 1);\n                x >>>= 1;\n            }\n            return y;\n        }\n    }\n\n    // Post-process complex DFT into two real channels.\n    // X[k] =    0.5 Z[k] + Z*[N-k]\n    // Y[k] = -j 0.5 Z[k] - Z*[N-k]\n    // left channel is index 0 to n/2-1, right channel is index n-1 to n/2.\n    // s.a. http://www.ti.com/lit/an/spra291/spra291.pdf\n    splitreal(real, imag) {\n        const n = this.n;\n        //real[0] = real[0]\n        imag[0] = 0\n        real[n / 2] = imag[0]\n        imag[n / 2] = 0\n        for (let i = 1; i < n / 2; i += 1) {\n            const lr = 0.5 * (real[i] + real[n - i])\n            const li = 0.5 * (imag[i] - imag[n - i])\n            const rr = 0.5 * (imag[i] + imag[n - i])\n            const ri = 0.5 * (-real[i] + real[n - i])\n            real[i] = lr\n            imag[i] = li\n            real[n - i] = rr\n            imag[n - i] = ri\n        }\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FFTNayuki);\n\n\n//# sourceURL=webpack://demo3/./node_modules/spectroplot/lib/fft_nayuki.js?");

/***/ }),

/***/ "./node_modules/spectroplot/lib/polyfill.js":
/*!**************************************************!*\
  !*** ./node_modules/spectroplot/lib/polyfill.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/**\n    @file Various polyfill snippets from MDN.\n\n    @copyright CC0 Licenses for code examples and snippets\n    @license\n    Any copyright is dedicated to the Public Domain. http://creativecommons.org/publicdomain/zero/1.0/\n*/\n\n// polyfill: Object.assign\nif (!Object.assign)\n    Object.assign = function (target, ...sources) {\n        return sources.reduce(function (r, o) {\n            Object.keys(o).forEach(function (k) {\n                r[k] = o[k];\n            });\n            return r;\n        }, target);\n    };\n\n// polyfill: Math.clamp\nif (!Math.clamp)\n    Math.clamp = function (x, lower, upper) {\n        return Math.max(lower, Math.min(x, upper));\n    };\n\n// polyfill: Math.log10\nif (!Math.log10)\n    Math.log10 = function (x) {\n        return Math.log(x) * Math.LOG10E;\n    };\n\n\n// polyfill: Math.log2\nif (!Math.log2)\n    Math.log2 = function (x) {\n        return Math.log(x) * Math.LOG2E;\n    };\n\n// polyfill IE: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill\nif (!Array.prototype.fill)\n    Object.defineProperty(Array.prototype, 'fill', {\n        value: function (value) {\n\n            // Steps 1-2.\n            if (this == null) {\n                throw new TypeError('this is null or not defined');\n            }\n\n            var O = Object(this);\n\n            // Steps 3-5.\n            var len = O.length >>> 0;\n\n            // Steps 6-7.\n            var start = arguments[1];\n            var relativeStart = start >> 0;\n\n            // Step 8.\n            var k = relativeStart < 0 ?\n                Math.max(len + relativeStart, 0) :\n                Math.min(relativeStart, len);\n\n            // Steps 9-10.\n            var end = arguments[2];\n            var relativeEnd = end === undefined ?\n                len : end >> 0;\n\n            // Step 11.\n            var final = relativeEnd < 0 ?\n                Math.max(len + relativeEnd, 0) :\n                Math.min(relativeEnd, len);\n\n            // Step 12.\n            while (k < final) {\n                O[k] = value;\n                k++;\n            }\n\n            // Step 13.\n            return O;\n        }\n    });\n\n\n//# sourceURL=webpack://demo3/./node_modules/spectroplot/lib/polyfill.js?");

/***/ }),

/***/ "./node_modules/spectroplot/lib/samples.js":
/*!*************************************************!*\
  !*** ./node_modules/spectroplot/lib/samples.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n    @file Class for viewing sample formats.\n\n    @author Christian W. Zuckschwerdt <zany@triq.net>\n    @copyright Christian W. Zuckschwerdt, 2019\n    @license\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n*/\n\n/** Class for viewing sample formats. */\nclass SampleView {\n    constructor(format, buffer, sampleRate, centerFreq) {\n        /** A float representing the sample rate, in samples per second, of the data stored in the buffer. */\n        this.sampleRate = sampleRate || 250000\n\n        /** A float representing the center frequency, in Hz, of the data stored in the buffer. */\n        this.centerFreq = centerFreq || 0\n\n        format = format.toUpperCase()\n        /** A string representing the data format, of the data stored in the buffer. */\n        this.format = format\n\n        // TODO: Endianess?\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\n\n        let typedArray, sampleBias, sampleScale, sampleWidth\n        if (format == 'CU4') {\n            // CU4 - Uint8Array (needs unpacking)\n            sampleBias = 7.5\n            sampleScale = 1.0 / 7.5\n            sampleWidth = 1 // bytes\n            typedArray = Uint8Array\n            this.sampleI = this.unpackI_CU4\n            this.sampleQ = this.unpackQ_CU4\n        }\n        else if (format == 'CS4') {\n            // CS4 - Uint8Array (needs unpacking)\n            sampleBias = 0\n            sampleScale = 1.0 / 8.0\n            sampleWidth = 1 // bytes\n            typedArray = Uint8Array\n            this.sampleI = this.unpackI_CS4\n            this.sampleQ = this.unpackQ_CS4\n        }\n        else if (format == 'CU8' || format == 'DATA' || format == 'COMPLEX16U') {\n            // CU8 - Uint8Array\n            sampleBias = 127.5 // or 127? or 128?\n            sampleScale = 1.0 / 127.5\n            sampleWidth = 2 // bytes\n            typedArray = Uint8Array\n        }\n        else if (format == 'CS8' || format == 'COMPLEX16S') {\n            // CS8 - Int8Array\n            sampleBias = 0\n            sampleScale = 1.0 / 128.0\n            sampleWidth = 2 // bytes\n            typedArray = Int8Array\n        }\n        else if (format == 'CU16') {\n            // CU16 - Uint16Array\n            sampleBias = 32767.5\n            sampleScale = 1.0 / 32768.0\n            sampleWidth = 4 // bytes\n            typedArray = Uint16Array\n        }\n        else if (format == 'CS16') {\n            // CS16 - Int16Array\n            sampleBias = 0\n            sampleScale = 1.0 / 32768.0\n            sampleWidth = 4 // bytes\n            typedArray = Int16Array\n        }\n        else if (format == 'CU12') {\n            // CU12 - Uint8Array (needs unpacking)\n            sampleBias = 2047.5\n            sampleScale = 1.0 / 2047.5\n            sampleWidth = 3 // bytes\n            typedArray = Uint8Array\n            this.sampleI = this.unpackI_CU12\n            this.sampleQ = this.unpackQ_CU12\n        }\n        else if (format == 'CS12') {\n            // CS12 - Uint8Array (needs unpacking)\n            sampleBias = 0\n            sampleScale = 1.0 / 2048.0\n            sampleWidth = 3 // bytes\n            typedArray = Uint8Array\n            this.sampleI = this.unpackI_CS12\n            this.sampleQ = this.unpackQ_CS12\n        }\n        else if (format == 'CU32') {\n            // CU32 - Uint32Array\n            sampleBias = 2147483647.5\n            sampleScale = 1.0 / 2147483648.0\n            sampleWidth = 8 // bytes\n            typedArray = Uint32Array\n        }\n        else if (format == 'CS32') {\n            // CS32 - Int32Array\n            sampleBias = 0\n            sampleScale = 1.0 / 2147483648.0\n            sampleWidth = 8 // bytes\n            typedArray = Int32Array\n        }\n        else if (format == 'CU64') {\n            // CU64 - Uint64Array (needs translation)\n            sampleBias = 1.0\n            sampleScale = 1.0\n            sampleWidth = 16 // bytes\n            typedArray = Uint32Array\n            this.sampleI = this.unpackI_CU64\n            this.sampleQ = this.unpackQ_CU64\n        }\n        else if (format == 'CS64') {\n            // CS64 - Int64Array (needs translation)\n            sampleBias = 0\n            sampleScale = 1.0\n            sampleWidth = 16 // bytes\n            typedArray = Uint32Array\n            this.sampleI = this.unpackI_CS64\n            this.sampleQ = this.unpackQ_CS64\n        }\n        else if (format == 'CF32' || format == 'CFILE' || format == 'COMPLEX') {\n            // CF32 - Float32Array\n            sampleBias = 0\n            sampleScale = 1.0\n            sampleWidth = 8 // bytes\n            typedArray = Float32Array\n        }\n        else if (format == 'CF64') {\n            // CF64 - Float64Array\n            sampleBias = 0\n            sampleScale = 1.0\n            sampleWidth = 16 // bytes\n            typedArray = Float64Array\n        }\n        // https://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats#Browser_compatibility\n        else if (format == 'WAV' || format == 'BWF' || format == 'WEBM' || format == 'OGG' || format == 'OPUS'\n                || format == 'FLAC' || format == 'MP4' || format == 'M4A' || format == 'AAC' || format == 'MP3') {\n            buffer = null // need to wait for Promise resolve\n            sampleWidth = 8 // bytes\n            this.sampleI = this.unpackI_audio\n            this.sampleQ = this.unpackQ_audio\n            this.format = 'CF32' // force format on decompressed buffer\n        }\n        else {\n            // default to CU8 - Uint8Array\n            sampleBias = 127.5 // or 127? or 128?\n            sampleScale = 1.0 / 127.5\n            sampleWidth = 2 // bytes\n            typedArray = Uint8Array\n        }\n        this.sampleBias = sampleBias\n        this.sampleScale = sampleScale\n        this.sampleWidth = sampleWidth\n        this.typedArray = typedArray\n\n        if (buffer) {\n            this.buffer = buffer\n            this.view = new typedArray(buffer)\n            // generally:\n            // this.sampleCount = this.view.length / 2 // I+Q\n            // but for CS12 rather:\n            this.sampleCount = buffer.byteLength / this.sampleWidth\n        }\n    }\n\n    loadBuffer(buffer) {\n        if (this.typedArray) {\n            this.buffer = buffer\n            this.view = new this.typedArray(buffer)\n            // generally:\n            // this.sampleCount = this.view.length / 2 // I+Q\n            // but for CS12 rather:\n            this.sampleCount = buffer.byteLength / this.sampleWidth\n            return Promise.resolve()\n        } else {\n            return this.readAudio(buffer)\n        }\n    }\n\n    /// This will give a noisy envelope of OOK/ASK signals.\n    /// Subtracts the bias (-128) and calculates the norm (scaled by 16384).\n    amplitude_cu8() {\n        const am_buf = new Uint16Array(this.sampleCount)\n        for (let i = 0; i < this.sampleCount; i++) {\n            let x = 127 - this.view[2 * i]\n            let y = 127 - this.view[2 * i + 1]\n            am_buf[i]  = x * x + y * y // max 32768, fs 16384\n        }\n        return am_buf\n    }\n\n    /// 122/128, 51/128 Magnitude Estimator for CU8 (SIMD has min/max).\n    /// Note that magnitude emphasizes quiet signals / deemphasizes loud signals.\n    magnitude_est_cu8() {\n        const am_buf = new Uint16Array(this.sampleCount)\n        for (let i = 0; i < this.sampleCount; i++) {\n            let x = Math.abs(this.view[2 * i] - 128)\n            let y = Math.abs(this.view[2 * i + 1] - 128)\n            let mi = x < y ? x : y\n            let mx = x > y ? x : y\n            let mag_est = 122 * mx + 51 * mi\n            am_buf[i] = mag_est // max 22144, fs 16384\n        }\n        return am_buf\n    }\n\n    /// True Magnitude for CU8 (sqrt can SIMD but float is slow).\n    magnitude_true_cu8() {\n        const am_buf = new Uint16Array(this.sampleCount)\n        for (let i = 0; i < this.sampleCount; i++) {\n            let x = this.view[2 * i] - 128\n            let y = this.view[2 * i + 1] - 128\n            am_buf[i]  = Math.sqrt(x * x + y * y) * 128.0 // max 181, scaled 23170, fs 16384\n        }\n        return am_buf\n    }\n\n    /// 122/128, 51/128 Magnitude Estimator for CS16 (SIMD has min/max).\n    magnitude_est_cs16() {\n        const am_buf = new Uint16Array(this.sampleCount)\n        for (let i = 0; i < this.sampleCount; i++) {\n            let x = Math.abs(this.view[2 * i])\n            let y = Math.abs(this.view[2 * i + 1])\n            let mi = x < y ? x : y\n            let mx = x > y ? x : y\n            let mag_est = 122 * mx + 51 * mi\n            am_buf[i] = mag_est >> 8 // max 5668864, scaled 22144, fs 16384\n        }\n        return am_buf\n    }\n\n    /// True Magnitude for CS16 (sqrt can SIMD but float is slow).\n    magnitude_true_cs16() {\n        const am_buf = new Uint16Array(this.sampleCount)\n        for (let i = 0; i < this.sampleCount; i++) {\n            let x = this.view[2 * i]\n            let y = this.view[2 * i + 1]\n            am_buf[i]  = Math.sqrt(x * x + y * y) >> 1 // max 46341, scaled 23170, fs 16384\n        }\n        return am_buf\n    }\n\n    /** The duration property returns a double representing the duration, in seconds, of the data stored in the buffer. */\n    get duration() {\n        return this.sampleCount / this.sampleRate\n    }\n\n    slice(sliceIndex, sliceCount, startSample, endSample) {\n        startSample = startSample || 0\n        endSample = endSample || ~~(this.sampleCount)\n        const sliceLength = this.sampleWidth * ~~((endSample - startSample) / sliceCount)\n        return this.buffer.slice(startSample * this.sampleWidth + sliceLength * sliceIndex, startSample * this.sampleWidth + sliceLength * (sliceIndex + 1))\n    }\n\n    readAudio(audioData) {\n        const audioCtx = new (window.AudioContext || window.webkitAudioContext)()\n        return audioCtx.decodeAudioData(audioData)\n            .then(buffer => {\n                this.audioBuffer = buffer\n                this.sampleCount = buffer.length\n                this.sampleRate = buffer.sampleRate\n                this.view = this.interleaved()\n                this.buffer = this.view.buffer\n                //console.log('decodeAudioData', buffer, this.view, this.buffer)\n            })\n            .catch(error => {\n                if (!this.audioBuffer)\n                    throw `decodeAudioData error: ${error}`\n            })\n    }\n    interleaved() {\n        if (!this.audioBuffer)\n            throw 'AudioBuffer not initialized'\n        if (this.audioBuffer.numberOfChannels != 2)\n            throw `AudioBuffer wrong numberOfChannels (${this.audioBuffer.numberOfChannels})`\n        const n = this.sampleCount\n        const data = new Float32Array(n * 2)\n        const ch0 = this.audioBuffer.getChannelData(0)\n        const ch1 = this.audioBuffer.getChannelData(1)\n        for (let i = 0; i < n; i += 1) {\n            data[2 * i + 0] = ch0[i]\n            data[2 * i + 1] = ch1[i]\n        }\n        return data\n    }\n    unpackI_audio(pos) {\n        const channel = this.audioBuffer.getChannelData(0)\n        return channel[pos]\n    }\n    unpackQ_audio(pos) {\n        const channel = this.audioBuffer.getChannelData(1)\n        return channel[pos]\n    }\n\n    // read 8 bit (iq), note the intermediate is Q0.3, LSB aligned\n    unpackI_CU4(pos) {\n        const b0 = this.view[1 * pos + 0]\n        const s = (b0 & 0xf0) >> 4\n        return (s - this.sampleBias) * this.sampleScale\n    }\n    unpackQ_CU4(pos) {\n        const b0 = this.view[1 * pos + 0]\n        const s = (b0 & 0x0f) >> 0\n        return (s - this.sampleBias) * this.sampleScale\n    }\n\n    // read 8 bit (iq), note the intermediate is Q0.31, MSB aligned Int32 for sign-extend\n    unpackI_CS4(pos) {\n        const b0 = this.view[1 * pos + 0]\n        const s = ((b0 & 0xf0) << 24) >> 28\n        return s * this.sampleScale\n    }\n    unpackQ_CS4(pos) {\n        const b0 = this.view[1 * pos + 0]\n        const s = ((b0 & 0x0f) << 28) >> 28\n        return s * this.sampleScale\n    }\n\n    // read 24 bit (iiqIQQ), note the intermediate is Q0.12, LSB aligned\n    unpackI_CU12(pos) {\n        const b0 = this.view[3 * pos + 0]\n        const b1 = this.view[3 * pos + 1]\n        const s = ((b1 & 0x0f) << 8) | (b0)\n        return (s - this.sampleBias) * this.sampleScale\n    }\n    unpackQ_CU12(pos) {\n        const b1 = this.view[3 * pos + 1]\n        const b2 = this.view[3 * pos + 2]\n        const s = (b2 << 4) | ((b1 & 0xf0) >> 4)\n        return (s - this.sampleBias) * this.sampleScale\n    }\n\n    // read 24 bit (iiqIQQ), note the intermediate is Q0.31, MSB aligned Int32 for sign-extend\n    unpackI_CS12(pos) {\n        const b0 = this.view[3 * pos + 0]\n        const b1 = this.view[3 * pos + 1]\n        const s = (((b1 & 0x0f) << 28) | (b0 << 20)) >> 20\n        return s * this.sampleScale\n    }\n    unpackQ_CS12(pos) {\n        const b1 = this.view[3 * pos + 1]\n        const b2 = this.view[3 * pos + 2]\n        const s = ((b2 << 24) | ((b1 & 0xf0) << 16)) >> 20\n        return s * this.sampleScale\n    }\n\n    // read 64 bit signed data as 53 bits float, this might loose lots of precision\n    unpackI_CU64(pos) {\n        const b0 = this.view[4 * pos + 0]\n        const b1 = this.view[4 * pos + 1]\n        const s = (b1) / 2 ** 31 + (b0 / 2 ** 64)\n        return (s - this.sampleBias)\n    }\n    unpackQ_CU64(pos) {\n        const b0 = this.view[4 * pos + 2]\n        const b1 = this.view[4 * pos + 3]\n        const s = (b1) / 2 ** 31 + (b0 / 2 ** 64)\n        return (s - this.sampleBias)\n    }\n\n    // read 64 bit signed data as 53 bits float, this might loose lots of precision\n    unpackI_CS64(pos) {\n        const b0 = this.view[4 * pos + 0]\n        const b1 = this.view[4 * pos + 1]\n        const s = (b1 >> 0) / 2 ** 31 + (b0 / 2 ** 64)\n        return s\n    }\n    unpackQ_CS64(pos) {\n        const b0 = this.view[4 * pos + 2]\n        const b1 = this.view[4 * pos + 3]\n        const s = (b1 >> 0) / 2 ** 31 + (b0 / 2 ** 64)\n        return s\n    }\n\n    /** The sample of the I-channel at index `pos`, of the data stored in the buffer. */\n    sampleI(pos) {\n        return (this.view[2 * pos + 0] - this.sampleBias) * this.sampleScale\n    }\n\n    /** The sample of the Q-channel at index `pos`, of the data stored in the buffer. */\n    sampleQ(pos) {\n        return (this.view[2 * pos + 1] - this.sampleBias) * this.sampleScale\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SampleView);\n\n\n//# sourceURL=webpack://demo3/./node_modules/spectroplot/lib/samples.js?");

/***/ }),

/***/ "./node_modules/spectroplot/lib/worker.js":
/*!************************************************!*\
  !*** ./node_modules/spectroplot/lib/worker.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfill.js */ \"./node_modules/spectroplot/lib/polyfill.js\");\n/* harmony import */ var _samples_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./samples.js */ \"./node_modules/spectroplot/lib/samples.js\");\n/* harmony import */ var _fft_nayuki_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fft_nayuki.js */ \"./node_modules/spectroplot/lib/fft_nayuki.js\");\n/**\n    @file Worker to render an FFT to image.\n\n    @author Christian W. Zuckschwerdt <zany@triq.net>\n    @copyright Christian W. Zuckschwerdt, 2019\n    @license\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n*/\n\n/*eslint no-console: \"off\"*/\n\n\n\n\n\nlet fftN\nlet fft\n\n/** Function for rendering an FFT to image. */\nfunction renderFft(ctx) {\n    const sampleView = new _samples_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](ctx.format, ctx.buffer);\n    const gauge_mins = new Uint8ClampedArray(new ArrayBuffer(ctx.width));\n    const gauge_maxs = new Uint8ClampedArray(new ArrayBuffer(ctx.width));\n    const gauge_amps = new Uint8ClampedArray(new ArrayBuffer(ctx.width));\n\n    const sampleCount = sampleView.sampleCount;\n\n    const block_norm = ctx.block_norm;\n    const block_norm_db = 10 * Math.log10(block_norm);\n    const gain = ctx.gain;\n    const dB_range = ctx.range;\n    let dBfs_min = 0.0;\n    let dBfs_max = -200.0;\n    const cmap = ctx.cmap;\n    const color_max = cmap.length - 1;\n    const color_norm = cmap.length / -dB_range;\n\n    const cB_hist_size = 1000; // centi Bell (0.1 dB)\n    const cB_hist = new Array(cB_hist_size).fill(0); // -0.0 to -100.0 dB\n    const c_hist = new Array(cmap.length).fill(0);\n\n    const n = ctx.n;\n    const windowc = ctx.windowc;\n    const height = n;\n    const width = ctx.width;\n    const points = width;\n    const stride = (sampleCount - n) / (points - 1);\n    const indexed = ctx.indexed\n    const waterfall = ctx.waterfall\n    // const imageData = new ImageData(width, height); // would need polyfill\n    const byteCount = indexed ? width * height : 4 * width * height\n    const imageData = { data: new Uint8ClampedArray(byteCount) };\n    ////const imageBuffer = new ArrayBuffer(width * height * 4);\n    //const imageBuffer = ctx.image;\n    //const imageData = new Uint8ClampedArray(imageBuffer);\n\n    if (fftN != n) {\n        fft = new _fft_nayuki_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](n);\n        fftN = n;\n    }\n    const real = new Array(n);\n    const imag = new Array(n);\n\n    //console.time('fft worker');\n    // faster to cast floats to int with bitwise nops than Math.round\n    for (let x = 0; x < width; x++) {\n\n        for (let k = 0; k < n; k++) {\n            //const pos = 2 * (Math.round(stride * x) + k);\n            const pos = ~~(0.5 + stride * x) + k;\n            real[k] = windowc[k] * sampleView.sampleI(pos);\n            imag[k] = windowc[k] * sampleView.sampleQ(pos);\n        }\n\n        fft.transform(real, imag);\n        if (ctx.channelMode) {\n            fft.splitreal(real, imag);\n        }\n\n        let dBfs_min_i = 0.0;\n        let dBfs_max_i = -200.0;\n\n        for (let i = 0; i < n; i++) {\n        // for (let y = 0; y < n; y++) {\n            // the positive frequencies are stored in the first half and\n            // the negative frequencies are stored in backwards order in the second half.\n            // (The frequency -k/n is the same as the frequency (n-k)/n.)\n            const y = i <= n / 2 ? n / 2 - i : n / 2 + n - i;\n            //const i = y < n / 2 ? n / 2 - 1 - y : n / 2 - 1 + n - y;\n            const abs2 = real[i] * real[i] + imag[i] * imag[i];\n            let dBfs = 5 * Math.log10(abs2) + block_norm_db + gain;\n\n            //                const mean = 22;\n            //                const sdev = 1;\n            //                const xg = (-dBfs - mean) / sdev;\n            //                const gauss = 1 / sdev * 1 / Math.sqrt(2 * Math.PI) * Math.exp(-0.5 * xg * xg);\n            //                //console.log(gauss);\n            //                dBfs *= gauss * 8 - 6;\n\n            if (dBfs - gain < dBfs_min_i) dBfs_min_i = dBfs - gain;\n            if (dBfs - gain > dBfs_max_i) dBfs_max_i = dBfs - gain;\n\n            const cBabs = ~~(0.5 + (dBfs - gain) * -10);\n            cB_hist[cBabs >= cB_hist_size ? cB_hist_size - 1 : cBabs] += 1;\n\n            //const gray = color_max - Math.clamp(Math.round(dBfs * color_norm), 0, color_max);\n            //const gray = Math.round(Math.clamp(color_max - dBfs * color_norm, 0, color_max));\n            //const gray = ~~(0.5 + Math.clamp(color_max - dBfs * color_norm, 0, color_max));\n            const grayU = color_max - dBfs * color_norm;\n            const gray = ~~(0.5 + (grayU < 0 ? 0 : grayU > color_max ? color_max : grayU));\n            c_hist[gray] += 1;\n            if (indexed) {\n                if (waterfall) {\n                    imageData.data[height * x + y] = gray\n                } else /*spectrogram*/ {\n                    imageData.data[x + width * y] = gray\n                }\n            } else {\n                const color = cmap[gray];\n                const j = waterfall\n                    ? height * (width - 1 - x) * 4 + (n - 1 - y) * 4\n                    : x * 4 + width * y * 4;\n                imageData.data[j + 0] = color[0]; // R\n                imageData.data[j + 1] = color[1]; // G\n                imageData.data[j + 2] = color[2]; // B\n                imageData.data[j + 3] = 255; // A\n            }\n        }\n\n        if (dBfs_min_i < dBfs_min) dBfs_min = dBfs_min_i;\n        if (dBfs_max_i > dBfs_max) dBfs_max = dBfs_max_i;\n\n        // amplitude gauge\n        gauge_mins[x] = 0.5 + (dB_range + dBfs_min_i) * 256 / dB_range;\n        gauge_maxs[x] = 0.5 + (dB_range + dBfs_max_i) * 256 / dB_range;\n\n        const mid = ~~(0.5 + stride * x) + n/2;\n        const re =  sampleView.sampleI(mid);\n        const im =  sampleView.sampleQ(mid);\n        const abs2 = re * re + im * im;\n        let dBfs_amp = 5 * Math.log10(abs2) + gain;\n        gauge_amps[x] = 0.5 + (dB_range + dBfs_amp) * 256 / dB_range;\n    }\n    //console.timeEnd('fft worker');\n\n    postMessage({\n        cB_hist: cB_hist,\n        c_hist: c_hist,\n        dBfs_min: dBfs_min,\n        dBfs_max: dBfs_max,\n        offset: ctx.offset,\n        gauge_mins: gauge_mins,\n        gauge_maxs: gauge_maxs,\n        gauge_amps: gauge_amps,\n        imageData: imageData,\n    }, [\n        gauge_mins.buffer,\n        gauge_maxs.buffer,\n        gauge_amps.buffer,\n        imageData.data.buffer,\n    ]);\n}\n\nonmessage = function (e) {\n    if (e.data && e.data.buffer) {\n        if (self.performance)\n            performance.mark('render-start');\n\n        renderFft(e.data);\n\n        if (self.performance) {\n            performance.mark('render-end');\n            performance.measure('render', 'render-start', 'render-end');\n\n            // Get all of the measures out.\n            // In this case there is only one.\n            var measures = performance.getEntriesByName('render');\n            var measure = measures[0];\n            console.log(`worker render: ${measure.duration.toFixed(2)}ms`);\n\n            // Clean up the stored markers.\n            performance.clearMarks();\n            performance.clearMeasures();\n        }\n    }\n};\n\n\n//# sourceURL=webpack://demo3/./node_modules/spectroplot/lib/worker.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./node_modules/spectroplot/lib/worker.js");
/******/ 	
/******/ })()
;